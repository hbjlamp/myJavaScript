<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>oop 继承</title>
	<script type="text/javascript">
		var SuperClass = function(){
			this.books = ['JavaScript','html','css'];
		}

		function SubClass(){}
		SubClass.prototype = new SuperClass();

		var instance1 = new SubClass();
		var instance2 = new SubClass();
		console.log(instance2.books);
		instance1.books.push('设计模式');
		console.log(instance2.books);

		// 此种继承模式的两个缺陷
		// 一、子类示例更改子类原型从父类构造函数中继承来的共有属性值会影响其他子类
		// 二、由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因而
		// 在实例化父类的时候也无法对父类构造函数类的属性进行初始化
		// 解决方式是--构造函数
	</script>
</head>
<body>

</body>
</html>